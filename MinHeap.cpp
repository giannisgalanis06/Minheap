#include <iostream>
#include "MinHeap.h"
#include <string>
#include <fstream>
using namespace std;


void MinHeap::antimetatheseis(int i)
{
    int small=i; //ο δεικτης στο μικρότεροκόμβος(ο γονιος)
    int l=2*i+1; //ο δεικτης στο αριστερο παιδί
    int r=2*i+2; //ο δεικτης στο δεξίς παιδί

    if(l<N) //ελέγχω αν υπάρχει το αριστερό παιδί
    {
        if(heap[l]<heap[small]) //αν το αριστερό παιδί μικροτερο απο γονιο ο μικροτερος δείκτης ο αριστερος
            small=l;
    }
    if(r<N) // ελέγχω αν υπάρχει το δεξί παιδι
    {
      if(heap[r]<heap[small]) //αν το δεξι παιδί μικροτερο απο γονιο ο δείκτης μικροτεροςο ο δεξις
        small=r;
    }
        if(small!=i) //αυτό ελέξχει αν άλλαξε το small δηλαδή αν κάποιο απο τα παιδιά είναι μικρότερό του
            {
                // αντιμεταθέτω το heap[i] που είναι ο γονιός με το μικρότερο παιδί
                int temp=heap[i];
                heap[i]=heap[small];
                heap[small]=temp;
    /*Χρησιμοποιώ αναδρομή ωστε να γίνει η ίδια διαδικασία αν το υποδέντρο
    εχει μεγαλύτερο ΄ύψος απο 1 ωστε να πάει στο κατάλληλο επίπεδο ο κόμβος

    */
                antimetatheseis(small);
            }
}


MinHeap::MinHeap()  //δημιουργία κενου σωρου ελαχίστων
{
   heap=nullptr;
   N=0;
}


void MinHeap::BuildMinHeap(string filename)
{
    int a,i=0; //a διαβάζει αριθμους απο το αρχείο και i μετράει ποσους αριθμους εχει το αρχείο

    ifstream g; //ρευμα g να διαβάσει απο το αρχείο filename τις τιμες των κομβων
    g.open(filename);
    if(g.is_open())
        {
        while(g>>a) //βρίσκω πόσοι αριθμοι υπάρχουν στο filename αρχείο
        {
            i++;
        }
        heap=new int[i]; //δεσμέυω τον κατάλληλο χώρο εφόσον ξερω ποσα στοιχεία εχει το filename
        N=i;
        i=0;
        g.clear();  // ωστε να φυγει το EOF flag(αλλιως θα διαβασει τιποτα)
        g.seekg(0,ios::beg); //πηγαίνω τον δείκτη ανάγνωσης πάλι στην αρχη για να πάρω και τις τιμές εφόσον εμαθα πόσα στοιχεία έχει και δέσμευσα χωρο πίνακα
        while(g>>a) //βρίσκω πόσοι αριθμοι υπάρχουν στο filename αρχείο
        {
            heap[i]=a; //βάζω στον πίνακα τα στοιχεια με την σειρά
            i++;

        }
        //Με βάση την θεωρία στις δομές χρησιμοποιούμε bottom-up διαδικασία ξεκινώντας απο τους μέσα κόμβους(οχι φύλλα)
            for(int i=N/2-1;i>=0;i--)
                antimetatheseis(i);

        g.close();
        }else {cerr<<"File "<<filename<<" doesnt open";}

}



int MinHeap::GetSizeMinHeap()
{
    return N; //με βάση την εκφώνηση υποθέτουμε οτι πρώτα γίνεται η BUILD οπου υπολογίζω εκει το μεγεθος
}

void MinHeap::Insert(int number)
{
    N++; //αυξάνω το μέγεθος του πίνακα κατα μια μονάδα
    int *copyheap=new int[N]; //δημιουργώ αντίγραφο πίνακα με μια επιπλέον θέση για το στοιχείο
    for(int i=0;i<N-1;i++)
        copyheap[i]=heap[i]; //μέχρι τα Ν-1(χωρις το Ν-1) στοιχεία τα αντιγράφω

        copyheap[N-1]=number; //προσθέτω και το τελευταίο στοιχείο στο τέλος του πίνακα

    //Πλεον ο παλιος πίνακας δεν είναι ο κανονικός οπότε τον διαγράφω εφόσον καταναλώνει μνήμη
    delete[]heap;
    //και επειδή στην κλάση ιδιότητα είναι ο heap αντιγράφω τον copyheap
    heap=copyheap;

    //antimetatheseis(small);

    int i=N-1;
    while(i>0)
    {
        int g=(i-1)/2; //θέση γονιού κομβου i
        if(heap[i]<heap[g]) //αν ο κόμβος είναι μικρότερος απο το γονιό του τους αντιμεταθέτω
        {
            int temp=heap[i];
            heap[i]=heap[g];
            heap[g]=temp;
            i=g;
        }
        else break; // αν δεν είναι μικρότερη απο γονιό τότε σημαίνει οτι είναι στην σωστη θεση οποτε τελειώνει
    }

}

int MinHeap::FindMin()
{
    //εφόσον εχω κανει build γνωρίζουμε οτι στο minheap το ελαχιστον στοιχείο είναι η ρίζα δηλαδη το στοιχείο στην θεση 0 το πίνακα
    return heap[0];
}

void MinHeap::DeleteMin()
{
    int temp; //αντιμεταθέτω το τελευταίο στοιχείο του σωρού με τη ρίζα εφόσον θελω να την διαγράψω
    temp=heap[0];
    heap[0]=heap[N-1];
    heap[N-1]=temp;
        N--; //μειώνω το μέγεθος της σωρού
antimetatheseis(0); //κάνει κατάλληλες αντιμεταθέσεις στην ρίζα για να μπει στην σωστή θέση της



}



